#!/usr/bin/env python3

import pathlib
import struct
import sys

import binfile

from makeelf.elf import ELF, ELFDATA, EM, ET, SHN, STB, STT

def make_object(f, image, relocations, exports, section_name, symbol_suffix):
    elf = ELF(e_data=ELFDATA.ELFDATA2LSB, e_machine=EM.EM_X86_64, e_type=ET.ET_REL)

    bincode_id = elf.append_section(section_name, image, sec_addr=0)

    # If there are relocations, prepare a reference to the section
    if len(relocations):
        section_sym = elf.append_symbol(sym_name=None, sym_section=bincode_id, sym_offset=0, sym_size=0,
                sym_type=STT.STT_SECTION)

    # Add exported symbols
    for export in sorted(exports, key=lambda e: e.address):
        symbol_name = export.name + symbol_suffix
        elf.append_symbol(symbol_name, sym_section=bincode_id, sym_offset=export.address,
                sym_size=0, sym_binding=STB.STB_GLOBAL)

    # Convert relocations
    R_X86_64_PC32 = 2
    R_X86_64_32 = 10

    MAX_EXPECTED_16BIT_CODE_SIZE = 8 * 1024
    MAX_EXPECTED_IMAGE_SIZE = 1024 * 1024

    for reloc in sorted(relocations, key=lambda r: r.address):
        if reloc.type == binfile.Etype.IET_ABS_ADDR:
            assert reloc.symbol is None

            # extract addend from image
            addend, = struct.unpack("<I", image[reloc.address:reloc.address + 4])

            # Ignore nonsense relocations in 16-bit code until TempleRt is fixed
            if reloc.address < MAX_EXPECTED_16BIT_CODE_SIZE and addend > MAX_EXPECTED_IMAGE_SIZE:
                print(f"Warning: ignoring big addend {addend:08X}h for {reloc.type} @ {reloc.address:08X}h")
                continue

            elf.append_reloc(sec_name=section_name, r_offset=reloc.address, type=R_X86_64_32,
                    sym=section_sym, r_addend=addend)

            # zero out the location; probably not necessary, just to reduce confusion
            image[reloc.address:reloc.address + 4] = b"\0\0\0\0"
        elif reloc.type == binfile.Etype.IET_REL_I32:
            assert reloc.symbol is not None

            symbol_name = reloc.symbol + symbol_suffix
            # TODO: cache symbol entries
            sym = elf.append_symbol(symbol_name, sym_section=SHN.SHN_UNDEF, sym_offset=0, sym_size=0,
                    sym_binding=STB.STB_GLOBAL)

            elf.append_reloc(sec_name=section_name, r_offset=reloc.address, type=R_X86_64_PC32,
                    sym=sym, r_addend=0)

            # zero out the location; probably not necessary, just to reduce confusion
            image[reloc.address:reloc.address + 4] = b"\0\0\0\0"
        else:
            raise Exception(f"Relocation not handled: {reloc}")

    f.write(bytes(elf))


NO_THUNK = object()
PLACEHOLDER_THUNK = object()


def get_symbol_definition(symbol):
    builtin_map = {
        b"ClassMemberLstDel": PLACEHOLDER_THUNK,
        b"CmpCtrlDel": PLACEHOLDER_THUNK,
        b"CmpCtrlNew": PLACEHOLDER_THUNK,
        b"DocSave": PLACEHOLDER_THUNK,
        b"DocUnlock": PLACEHOLDER_THUNK,
        b"Ed": PLACEHOLDER_THUNK,
        b"ExeFile": PLACEHOLDER_THUNK,
        b"ExePrint": PLACEHOLDER_THUNK,
        b"HostGetApiVersion": 0,
        b"HostGetEnv": 1,
        b"HostGetLocalTime": 1,
        b"Lex": PLACEHOLDER_THUNK,
        b"LexStmt2Bin": PLACEHOLDER_THUNK,
        b"SET_GS_BASE": NO_THUNK,
        b"U": PLACEHOLDER_THUNK,
        b"Ui": PLACEHOLDER_THUNK,
        b"_FREE": NO_THUNK,
    }

    if symbol in builtin_map:
        return builtin_map[symbol]

    raise Exception(f"Undefined symbol: {symbol}")


def make_thunks(f, relocations, exports, symbol_suffix):
    f.write("""/* This file is automatically generated -- do not edit! */
""")
    # Extract set of imported symbols
    symbols = set([r.symbol for r in relocations if r.symbol is not None])

    for symbol in sorted(symbols):
        defn = get_symbol_definition(symbol)

        if defn is NO_THUNK:
            continue

        try:
            thunk_name = (symbol + symbol_suffix).decode()
            plain_name = symbol.decode()
        except UnicodeDecodeError:
            print(f"Warning: skipping thunk generation for broken symbol name {symbol}")
            continue

        if defn is PLACEHOLDER_THUNK:
            f.write(f"""
.section    .text.{thunk_name}
.type       {thunk_name}, %function  
.global     {thunk_name}

{thunk_name}:
    jmp abort

    .size {thunk_name}, .-{thunk_name}
""")
        else:
            num_args = defn

            f.write(f"""
.section    .text.{thunk_name}
.type       {thunk_name}, %function  
.global     {thunk_name}

{thunk_name}:
    push %rdi
    push %rsi
    push %rdx
    push %rcx
    push %r8
    push %r9
    push %r10
    push %r11
""")

            if num_args >= 1:
                f.write("    mov 72(%rsp), %rdi\n")
            
            if num_args >= 2:
                f.write("    mov 80(%rsp), %rsi\n")

            if num_args >= 3:
                raise Exception("Too many arguments, not implemented")

            f.write(f"""
    call {plain_name}

    pop %r11
    pop %r10
    pop %r9
    pop %r8
    pop %rcx
    pop %rdx
    pop %rsi
    pop %rdi

    retq ${num_args * 8}

    .size {thunk_name}, .-{thunk_name}
""")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("binfile")
    parser.add_argument("-o", dest="output")
    parser.add_argument("-t", dest="thunks_output")
    parser.add_argument("--elf-section", default=".text")
    parser.add_argument("--symbol-suffix", default="$Temple")
    args = parser.parse_args()

    with open(args.binfile, "rb") as f:
        image, relocations, exports = binfile.parse(f)

    if args.output is not None:
        with open(args.output, "wb") as f:
            # TODO: parametrize section name

            make_object(f, image, relocations, exports,
                        section_name=args.elf_section.encode(),
                        symbol_suffix=args.symbol_suffix.encode())

    if args.thunks_output is not None:
        with open(args.thunks_output, "wt") as f:
            make_thunks(f, relocations, exports, symbol_suffix=args.symbol_suffix.encode())
